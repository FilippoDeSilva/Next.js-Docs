name: Build Next.js Docs PDF

on:
  push:
    paths:
      - 'nextjs-docs/canary_docs/**'
  workflow_dispatch:

jobs:
  build-docs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Cache tmp_mdx_project node_modules
        uses: actions/cache@v3
        with:
          path: tmp_mdx_project/node_modules
          key: tmp-mdx-${{ runner.os }}-node-${{ hashFiles('tmp_mdx_project/package-lock.json') }}
          restore-keys: |
            tmp-mdx-${{ runner.os }}-node-

      - name: Install dependencies
        run: |
          mkdir -p tmp_mdx_project
          cd tmp_mdx_project
          if [ ! -f package.json ]; then
            npm init -y
          fi
          npm install xdm react react-dom highlight.js puppeteer
          cd ..

      - name: Prepare directories
        run: |
          mkdir -p pdf-docs html_cache
          echo "DOCS_PATH=nextjs-docs/canary_docs" >> $GITHUB_ENV
          echo "HTML_FILE=pdf-docs/NextJS_Canary_Docs.html" >> $GITHUB_ENV
          echo "PDF_FILE=pdf-docs/NextJS_Canary_Docs.pdf" >> $GITHUB_ENV
          echo "FILES_JSON=tmp_files.json" >> $GITHUB_ENV

      - name: Collect MD/MDX files
        run: |
          if [ ! -d "$DOCS_PATH" ]; then
            echo "ERROR: Docs folder not found: $DOCS_PATH"
            exit 1
          fi
          mapfile -t files < <(find "$DOCS_PATH" -type f \( -name "*.md" -o -name "*.mdx" \) | sort)
          if [ "${#files[@]}" -eq 0 ]; then
            echo "No Markdown/MDX files found in $DOCS_PATH"
            exit 1
          fi
          printf '%s\n' "${files[@]}" | jq -R -s -c 'split("\n")[:-1]' > "$FILES_JSON"
          echo "Found ${#files[@]} files."

      - name: Build styled HTML + nested TOC
        run: |
          echo "<!DOCTYPE html><html><head><meta charset='UTF-8'>
          <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css'>
          <style>
          body { font-family: system-ui, sans-serif; line-height: 1.6; padding: 20px; background: #f7f8fa; color: #24292f; }
          h1,h2,h3,h4,h5,h6 { color: #0366d6; margin-top: 1.2em; }
          a { color: #0366d6; text-decoration: none; }
          a:hover { text-decoration: underline; }
          code { background: #eaeef2; padding: 2px 4px; border-radius: 4px; font-size: 0.95em; }
          pre { background: #eaeef2; padding: 10px; border-radius: 6px; overflow-x: auto; }
          table { border-collapse: collapse; width: 100%; }
          th, td { border: 1px solid #d1d5da; padding: 6px 12px; }
          th { background: #f6f8fa; }
          .toc { margin-bottom: 2em; padding: 10px; background: #e1e4e8; border-radius: 6px; }
          .toc ul { list-style:none; padding-left:1em; }
          .toc li { margin:2px 0; }
          </style></head><body>" > "$HTML_FILE"

          node -e "
          const fs = require('fs');
          const path = require('path');
          const { Worker } = require('worker_threads');

          const files = JSON.parse(fs.readFileSync('$FILES_JSON','utf8'));
          const htmlDir = path.resolve('html_cache');
          if(!fs.existsSync(htmlDir)) fs.mkdirSync(htmlDir);

          const maxWorkers = Math.min(require('os').cpus().length, 4);
          let index = 0;
          const tocItems = [];

          function runWorker(file) {
            return new Promise((resolve,reject)=>{
              const worker = new Worker(\`
                const { parentPort, workerData } = require('worker_threads');
                const fs = require('fs');
                const path = require('path');
                const React = require('react');
                const ReactDOMServer = require('react-dom/server');
                const { compile } = require('xdm');
                const hljs = require('highlight.js');

                (async () => {
                  try {
                    let content = fs.readFileSync(workerData.file,'utf8');
                    const fileSlug = path.basename(workerData.file).replace(/[\\\\s\\\\/]/g,'_');

                    const headingMatches = [...content.matchAll(/^(#+)\\\\s+(.*)$/gm)];
                    headingMatches.forEach((m,i)=>{
                      const level = m[1].length;
                      content = content.replace(m[0], '<h'+level+' id=\"'+fileSlug+'-'+i+'\">'+m[2]+'</h'+level+'>');
                    });

                    content = content.replace(/```(\\\\w*)\\\\n([\\\\s\\\\S]*?)```/g, (_, lang, code) => {
                      const validLang = hljs.getLanguage(lang) ? lang : 'plaintext';
                      return '<pre><code class=\"'+validLang+'\">'+hljs.highlight(code,{language: validLang}).value+'</code></pre>';
                    });

                    const mdxModule = await compile(content, { outputFormat: 'function-body', jsx:true });
                    const Component = new Function('React', mdxModule.value)(React);
                    const html = ReactDOMServer.renderToStaticMarkup(React.createElement(Component));

                    const outFile = path.join(workerData.htmlDir, fileSlug+'.html');
                    fs.writeFileSync(outFile, html);

                    parentPort.postMessage({file:fileSlug, headings: headingMatches.map((m,i)=>({text:m[2],id:fileSlug+'-'+i, level:m[1].length}))});
                  } catch(e) { parentPort.postMessage({error:e.message}); }
                })();
              \`, { eval:true, workerData:{file, htmlDir} });

              worker.on('message', resolve);
              worker.on('error', reject);
              worker.on('exit', code => { if(code!==0) reject(new Error('Worker exit '+code)); });
            });
          }

          async function runQueue() {
            const active = [];
            while(index < files.length || active.length > 0){
              while(index < files.length && active.length < maxWorkers){
                active.push(runWorker(files[index++]));
              }
              const result = await Promise.race(active);
              if(result.headings) tocItems.push({file: result.file, headings: result.headings});
              active.splice(active.findIndex(p => p===result),1);
            }
          }

          runQueue().then(()=>{
            fs.appendFileSync('$HTML_FILE','<div class=\"toc\"><h2>Table of Contents</h2><ul>');
            tocItems.sort((a,b)=>a.file.localeCompare(b.file)).forEach(item=>{
              item.headings.forEach(h=>{
                fs.appendFileSync('$HTML_FILE','<li style=\"margin-left:'+(h.level-1)+'em\"><a href=\"#'+h.id+'\">'+h.text+'</a></li>');
              });
            });
            fs.appendFileSync('$HTML_FILE','</ul></div>');

            const htmlFiles = fs.readdirSync(htmlDir).sort();
            for(const f of htmlFiles){
              fs.appendFileSync('$HTML_FILE', fs.readFileSync(path.join(htmlDir,f),'utf8') + '\\n');
            }
          }).catch(err=>{ console.error(err); process.exit(1); });
          "

      - name: Build PDF
        run: |
          node -e "
          const puppeteer = require('./tmp_mdx_project/node_modules/puppeteer');
          (async () => {
            const browser = await puppeteer.launch({args:['--no-sandbox','--disable-setuid-sandbox'], timeout:0});
            const page = await browser.newPage();
            await page.goto('file://' + process.cwd() + '/$HTML_FILE', {waitUntil: 'networkidle0'});
            await page.pdf({path: '$PDF_FILE', format: 'A4', printBackground: true});
            await browser.close();
          })();
          "

      - name: Upload HTML + PDF artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nextjs-docs
          path: |
            pdf-docs/NextJS_Canary_Docs.html
            pdf-docs/NextJS_Canary_Docs.pdf