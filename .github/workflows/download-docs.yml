name: Build Docs HTML + PDF

# Triggers: manual and daily at midnight UTC
on:
  workflow_dispatch: # Manual trigger
  schedule:          # Automatic trigger
    - cron: '0 0 * * *'  # Every day at 00:00 UTC

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Install dependencies
        run: |
          npm init -y
          npm install xdm react react-dom highlight.js puppeteer

      - name: Build HTML & PDF
        run: |
          set -euo pipefail

          mkdir -p pdf-docs html_cache
          DOCS_PATH="nextjs-docs/canary_docs"
          HTML_FILE="pdf-docs/NextJS_Canary_Docs.html"
          PDF_FILE="pdf-docs/NextJS_Canary_Docs.pdf"

          if [ ! -d "$DOCS_PATH" ]; then
            echo "ERROR: Docs folder not found: $DOCS_PATH"
            exit 1
          fi

          # Collect MD/MDX files
          mapfile -t files < <(find "$DOCS_PATH" -type f \( -name "*.md" -o -name "*.mdx" \) | sort)
          if [ "${#files[@]}" -eq 0 ]; then
            echo "No Markdown/MDX files found in $DOCS_PATH"
            exit 1
          fi

          FILES_JSON="tmp_files.json"
          printf '%s\n' "${files[@]}" | jq -R -s -c 'split("\n")[:-1]' > "$FILES_JSON"

          # Node builder script
          cat <<'EOF' > build_docs.js
          const fs = require('fs');
          const path = require('path');
          const { Worker } = require('worker_threads');
          const puppeteer = require('puppeteer');

          const files = JSON.parse(fs.readFileSync(process.env.FILES_JSON,'utf8'));
          const htmlDir = path.resolve('html_cache');
          if(!fs.existsSync(htmlDir)) fs.mkdirSync(htmlDir);

          const HTML_FILE = process.env.HTML_FILE;
          const PDF_FILE = process.env.PDF_FILE;

          fs.writeFileSync(HTML_FILE, `<!DOCTYPE html><html><head><meta charset='UTF-8'>
          <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css'>
          <style>
          body { font-family: system-ui, sans-serif; line-height: 1.6; padding: 20px; background: #f7f8fa; color: #24292f; }
          h1,h2,h3,h4,h5,h6 { color: #0366d6; margin-top: 1.2em; }
          a { color: #0366d6; text-decoration: none; }
          a:hover { text-decoration: underline; }
          code { background: #eaeef2; padding: 2px 4px; border-radius: 4px; font-size: 0.95em; }
          pre { background: #eaeef2; padding: 10px; border-radius: 6px; overflow-x: auto; }
          table { border-collapse: collapse; width: 100%; }
          th, td { border: 1px solid #d1d5da; padding: 6px 12px; }
          th { background: #f6f8fa; }
          .toc { margin-bottom: 2em; padding: 10px; background: #e1e4e8; border-radius: 6px; }
          .toc ul { list-style:none; padding-left:1em; }
          .toc li { margin:2px 0; }
          </style></head><body>`);

          const maxWorkers = Math.min(require('os').cpus().length, 4);
          let index = 0;
          const tocItems = [];

          function runWorker(file) {
            return new Promise((resolve,reject)=>{
              const workerCode = `
                const { parentPort, workerData } = require('worker_threads');
                const fs = require('fs');
                const path = require('path');
                const React = require('react');
                const ReactDOMServer = require('react-dom/server');
                const { compile } = require('xdm');
                const hljs = require('highlight.js');

                (async () => {
                  try {
                    let content = fs.readFileSync(workerData.file,'utf8');
                    const fileSlug = path.basename(workerData.file).replace(/[\\\\s\\\\/]/g,'_');

                    const headingMatches = [...content.matchAll(/^(#+)\\\\s+(.*)$/gm)];
                    headingMatches.forEach((m,i)=>{
                      const level = m[1].length;
                      content = content.replace(m[0], '<h'+level+' id="'+fileSlug+'-'+i+'">'+m[2]+'</h'+level+'>');
                    });

                    content = content.replace(/```(\\w*)\\n([\\s\\S]*?)```/g, (_, lang, code) => {
                      const validLang = hljs.getLanguage(lang) ? lang : 'plaintext';
                      return '<pre><code class="'+validLang+'">'+hljs.highlight(code,{language: validLang}).value+'</code></pre>';
                    });

                    const mdxModule = await compile(content, { outputFormat: 'function-body', jsx:true });
                    const Component = new Function('React', mdxModule.value)(React);
                    const html = ReactDOMServer.renderToStaticMarkup(React.createElement(Component));

                    const outFile = path.join(workerData.htmlDir, fileSlug+'.html');
                    fs.writeFileSync(outFile, html);

                    parentPort.postMessage({file:fileSlug, headings: headingMatches.map((m,i)=>({text:m[2],id:fileSlug+'-'+i, level:m[1].length}))});
                  } catch(e) { parentPort.postMessage({error:e.message}); }
                })();
              `;
              const worker = new Worker(workerCode, { eval:true, workerData:{file, htmlDir} });
              worker.on('message', resolve);
              worker.on('error', reject);
              worker.on('exit', code => { if(code!==0) reject(new Error('Worker exit '+code)); });
            });
          }

          async function runQueue() {
            const active = [];
            while(index < files.length || active.length > 0){
              while(index < files.length && active.length < maxWorkers){
                active.push(runWorker(files[index++]));
              }
              const result = await Promise.race(active);
              if(result.headings) tocItems.push({file: result.file, headings: result.headings});
              active.splice(active.findIndex(p => p===result),1);
            }
          }

          async function build() {
            await runQueue();

            fs.appendFileSync(HTML_FILE,'<div class="toc"><h2>Table of Contents</h2><ul>');
            tocItems.sort((a,b)=>a.file.localeCompare(b.file)).forEach(item=>{
              item.headings.forEach(h=>{
                fs.appendFileSync(HTML_FILE,'<li style="margin-left:'+(h.level-1)+'em"><a href="#'+h.id+'">'+h.text+'</a></li>');
              });
            });
            fs.appendFileSync(HTML_FILE,'</ul></div>');

            const htmlFiles = fs.readdirSync(htmlDir).sort();
            for(const f of htmlFiles){
              fs.appendFileSync(HTML_FILE, fs.readFileSync(path.join(htmlDir,f),'utf8') + '\\n');
            }

            fs.appendFileSync(HTML_FILE,'</body></html>');

            const browser = await puppeteer.launch({ args: ['--no-sandbox','--disable-setuid-sandbox'] });
            const page = await browser.newPage();
            await page.goto('file://' + path.resolve(HTML_FILE), { waitUntil: 'networkidle0' });
            await page.pdf({ path: PDF_FILE, format: 'A4', printBackground: true });
            await browser.close();

            console.log('âœ… HTML & PDF generated successfully!');
          }

          build().catch(err=>{ console.error(err); process.exit(1); });
          EOF

          FILES_JSON="$FILES_JSON" HTML_FILE="$HTML_FILE" PDF_FILE="$PDF_FILE" node build_docs.js

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nextjs-docs-pdf
          path: |
            pdf-docs/NextJS_Canary_Docs.pdf
            pdf-docs/NextJS_Canary_Docs.html