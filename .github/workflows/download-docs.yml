name: Generate Full Next.js Docs PDF

on:
  workflow_dispatch:

jobs:
  build_pdf:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies and tools
        run: |
          sudo apt-get update
          sudo apt-get install -y httrack
          npm install puppeteer pdf-lib

      - name: Scan Next.js Docs & detect pages
        id: scan_docs
        run: |
          echo "ðŸ” Scanning Next.js Docs index..."
          mkdir -p docs_temp

          # Mirror /docs only quietly to get page structure
          httrack "https://nextjs.org/docs" \
            --path docs_temp \
            --mirror \
            --robots=0 \
            --stay-on-same-domain \
            "-*" "+https://nextjs.org/docs*" \
            --depth=2 \
            --quiet \
            --sockets=4 \
            --updatehack

          # Detect folder where HTTrack stored the docs
          DOCS_DIR=$(find docs_temp -type d -name "docs" | head -1)
          if [[ -z "$DOCS_DIR" ]]; then
            echo "âŒ Could not find docs folder after HTTrack run!"
            exit 1
          fi
          echo "Docs folder detected: $DOCS_DIR"

          # List all HTML pages under /docs
          find "$DOCS_DIR" -type f -name '*.html' | sort -u > docs_urls.txt
          TOTAL_PAGES=$(wc -l < docs_urls.txt)
          echo "Found approximately $TOTAL_PAGES pages under /docs/"
          echo "total_pages=$TOTAL_PAGES" >> $GITHUB_OUTPUT
          echo "docs_dir=$DOCS_DIR" >> $GITHUB_OUTPUT

      - name: Mirror Next.js Docs with progress
        run: |
          echo "ðŸŒ Starting HTTrack mirror for nextjs.org/docs..."
          DOCS_DIR="${{ steps.scan_docs.outputs.docs_dir }}"
          TOTAL_PAGES="${{ steps.scan_docs.outputs.total_pages }}"

          LOG_FILE=docs_mirror/httrack.log
          mkdir -p docs_mirror
          > $LOG_FILE

          # Start HTTrack in background for live mirroring
          httrack "https://nextjs.org/docs" \
            --path docs_mirror \
            --mirror \
            --robots=0 \
            --stay-on-same-domain \
            "-*" "+https://nextjs.org/docs*" \
            --depth=2 \
            --sockets=4 \
            --updatehack \
            --verbose \
            --quiet \
            --keep-alive \
            --disable-security-limits \
            --max-rate=0 \
            --assume php,index.html,index.htm \
            --update \
            --continue &
          HT_PID=$!

          echo "â³ Mirroring in progress... (tracking downloaded pages)"
          while kill -0 $HT_PID 2>/dev/null; do
            DOWNLOADED=$(grep -c "Saving" $LOG_FILE || echo 0)
            PERCENT=$(( DOWNLOADED * 100 / TOTAL_PAGES ))
            BAR_LEN=40
            FILLED=$(( PERCENT * BAR_LEN / 100 ))
            BAR=$(printf "%-${BAR_LEN}s" "#" | cut -c1-$FILLED)
            printf "\rðŸ“„ Downloaded %d/%d pages [%s] %d%%" $DOWNLOADED $TOTAL_PAGES "$BAR" $PERCENT
            sleep 2
          done

          wait $HT_PID
          DOWNLOADED=$(grep -c "Saving" $LOG_FILE || echo 0)
          echo
          echo "âœ… HTTrack finished. Total pages downloaded: $DOWNLOADED"

      - name: Generate Full Docs PDF
        run: |
          node <<'EOF'
          const puppeteer = require('puppeteer');
          const fs = require('fs');
          const path = require('path');
          const { PDFDocument } = require('pdf-lib');

          const OUTPUT_PDF = 'NextJS_Full_Offline.pdf';
          const DOCS_DIR = process.env.DOCS_DIR || 'docs_mirror/nextjs.org/docs';

          async function* walk(dir) {
            for (const d of await fs.promises.readdir(dir, { withFileTypes: true })) {
              const fullPath = path.join(dir, d.name);
              if (d.isDirectory()) yield* walk(fullPath);
              else if (d.name.endsWith('.html')) yield fullPath;
            }
          }

          (async () => {
            const browser = await puppeteer.launch({
              headless: "new",
              args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage']
            });
            const page = await browser.newPage();
            page.setDefaultNavigationTimeout(0);

            const pdfBuffers = [];
            const files = [];
            for await (const filePath of walk(DOCS_DIR)) files.push(filePath);

            console.log('Rendering', files.length, 'pages...');
            let i = 0;
            for (const filePath of files) {
              i++;
              console.log(`[${i}/${files.length}] Rendering ${filePath}`);
              const url = `file://${path.resolve(filePath)}`;
              await page.goto(url, { waitUntil: 'networkidle2' });

              // Remove unwanted elements & apply styling
              await page.evaluate(() => {
                document.querySelectorAll('header, footer, nav, aside, [aria-label="Feedback"], [data-testid="docs-rating"]').forEach(el => el.remove());
                document.body.style.background = '#fff';
                document.body.style.color = '#000';
                document.body.style.margin = 'auto';
                document.body.style.maxWidth = '900px';
                document.body.style.fontFamily = 'Arial, sans-serif';
                document.querySelectorAll('details').forEach(d => (d.open = true));
                document.querySelectorAll('pre, code').forEach(el => {
                  el.style.whiteSpace = 'pre';
                  el.style.overflowX = 'auto';
                  el.style.background = '#f5f5f5';
                  el.style.padding = '10px';
                  el.style.borderRadius = '6px';
                });
                document.querySelectorAll('img').forEach(img => {
                  img.style.maxWidth = '100%';
                  img.style.display = 'block';
                  img.style.margin = '0 auto';
                });
              });

              const pdfBuffer = await page.pdf({
                format: 'A4',
                printBackground: true,
                preferCSSPageSize: true,
                margin: { top: 10, bottom: 30, left: 10, right: 10 }
              });

              pdfBuffers.push(pdfBuffer);
            }

            await browser.close();

            console.log('Merging PDFs...');
            const mergedPdf = await PDFDocument.create();
            for (const buf of pdfBuffers) {
              const doc = await PDFDocument.load(buf);
              const pages = await mergedPdf.copyPages(doc, doc.getPageIndices());
              pages.forEach(p => mergedPdf.addPage(p));
            }

            const finalBytes = await mergedPdf.save();
            fs.writeFileSync(OUTPUT_PDF, finalBytes);
            console.log('âœ… Full Next.js Docs PDF generated:', OUTPUT_PDF);
          })();
          EOF

      - name: Upload PDF
        uses: actions/upload-artifact@v4
        with:
          name: NextJS_Full_Offline
          path: NextJS_Full_Offline.pdf