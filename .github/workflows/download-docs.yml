name: Build Next.js Docs PDF

on:
  push:
    paths:
      - 'nextjs-docs/canary_docs/**'
  workflow_dispatch:

jobs:
  build-docs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install jq & highlight.js
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Create folders
        run: |
          mkdir -p pdf-docs html_cache tmp_mdx_project

      - name: Collect MD/MDX files
        run: |
          DOCS_PATH="nextjs-docs/canary_docs"
          FILES_JSON="tmp_files.json"
          if [ ! -d "$DOCS_PATH" ]; then
            echo "ERROR: Docs folder not found: $DOCS_PATH"
            exit 1
          fi
          mapfile -t files < <(find "$DOCS_PATH" -type f \( -name "*.md" -o -name "*.mdx" \) | sort)
          if [ "${#files[@]}" -eq 0 ]; then
            echo "No Markdown/MDX files found in $DOCS_PATH"
            exit 1
          fi
          printf '%s\n' "${files[@]}" | jq -R -s -c 'split("\n")[:-1]' > "$FILES_JSON"
          echo "Saved ${#files[@]} files to $FILES_JSON"

      - name: Initialize Node Project
        run: |
          cd tmp_mdx_project
          npm init -y
          npm install @mdx-js/mdx react react-dom xdm puppeteer highlight.js
          cd ../

      - name: Compile MDX â†’ Styled HTML with TOC
        run: |
          HTML_FILE="pdf-docs/NextJS_Canary_Docs.html"
          FILES_JSON="tmp_files.json"
          echo "<!DOCTYPE html><html><head><meta charset='UTF-8'>
          <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css'>
          <style>
          body { font-family: system-ui, sans-serif; line-height: 1.6; padding: 20px; background: #f7f8fa; color: #24292f; }
          h1,h2,h3,h4,h5,h6 { color: #0366d6; margin-top: 1.2em; }
          a { color: #0366d6; text-decoration: none; }
          a:hover { text-decoration: underline; }
          code { background: #eaeef2; padding: 2px 4px; border-radius: 4px; font-size: 0.95em; }
          pre { background: #eaeef2; padding: 10px; border-radius: 6px; overflow-x: auto; }
          table { border-collapse: collapse; width: 100%; }
          th, td { border: 1px solid #d1d5da; padding: 6px 12px; }
          th { background: #f6f8fa; }
          .toc { margin-bottom: 2em; padding: 10px; background: #e1e4e8; border-radius: 6px; }
          .toc a { display:block; margin:2px 0; }
          </style>
          </head><body>" > "$HTML_FILE"

          node -e "
          const fs = require('fs');
          const path = require('path');
          const { Worker } = require('worker_threads');
          const files = JSON.parse(fs.readFileSync('$FILES_JSON','utf8'));
          const htmlDir = path.resolve('html_cache');
          if(!fs.existsSync(htmlDir)) fs.mkdirSync(htmlDir);

          const maxWorkers = Math.min(require('os').cpus().length, 4);
          let index = 0;
          const tocItems = [];

          function runWorker(file){
            return new Promise((resolve,reject)=>{
              const worker = new Worker(\`
                const { parentPort, workerData } = require('worker_threads');
                const fs = require('fs');
                const path = require('path');
                const React = require('react');
                const ReactDOMServer = require('react-dom/server');
                const { compile } = require('xdm');
                const hljs = require('highlight.js');

                (async () => {
                  try {
                    let content = fs.readFileSync(workerData.file,'utf8');
                    const fileSlug = path.basename(workerData.file).replace(/[\\s\\/]/g,'_');
                    const headingMatches = [...content.matchAll(/^##?\\s+(.*)$/gm)];
                    headingMatches.forEach((m,i)=>content = content.replace(m[0], '<h2 id=\"'+fileSlug+'-'+i+'\">'+m[1]+'</h2>'));
                    content = content.replace(/\\`\\`\\`(\\\\w*)\\\\n([\\\\s\\\\S]*?)\\`\\`\\`/g, (_, lang, code) => {
                      const validLang = hljs.getLanguage(lang) ? lang : 'plaintext';
                      return '<pre><code class=\"'+validLang+'\">' + hljs.highlight(code,{language: validLang}).value + '</code></pre>';
                    });
                    const mdxModule = await compile(content, { outputFormat: 'function-body', jsx:true });
                    const Component = new Function('React', mdxModule.value)(React);
                    const html = ReactDOMServer.renderToStaticMarkup(React.createElement(Component));
                    const outFile = path.join(workerData.htmlDir, fileSlug+'.html');
                    fs.writeFileSync(outFile, html);
                    parentPort.postMessage({file:fileSlug, headings: headingMatches.map((m,i)=>({text:m[1],id:fileSlug+'-'+i}))});
                  } catch(e) { parentPort.postMessage({error:e.message}); }
                })();
              \`, { eval:true, workerData:{file, htmlDir} });
              worker.on('message', resolve);
              worker.on('error', reject);
              worker.on('exit', code => { if(code!==0) reject(new Error('Worker exit '+code)); });
            });
          }

          async function runQueue(){
            const active = [];
            while(index < files.length || active.length > 0){
              while(index < files.length && active.length < maxWorkers){
                active.push(runWorker(files[index++]));
              }
              const result = await Promise.race(active);
              if(result.headings) tocItems.push({file: result.file, headings: result.headings});
              active.splice(active.findIndex(p => p===result),1);
            }
          }

          runQueue().then(()=>{
            fs.appendFileSync('$HTML_FILE','<div class=\"toc\"><h2>Table of Contents</h2>');
            tocItems.sort((a,b)=>a.file.localeCompare(b.file)).forEach(item=>{
              item.headings.forEach(h=>{
                fs.appendFileSync('$HTML_FILE','<a href=\"#'+h.id+'\">'+h.text+'</a>');
              });
            });
            fs.appendFileSync('$HTML_FILE','</div>');
            const htmlFiles = fs.readdirSync(htmlDir).sort();
            for(const f of htmlFiles){
              fs.appendFileSync('$HTML_FILE', fs.readFileSync(path.join(htmlDir,f),'utf8') + '\\n');
            }
            fs.appendFileSync('$HTML_FILE','</body></html>');
          }).catch(err=>{ console.error(err); process.exit(1); });
          "

      - name: Generate PDF
        run: |
          PDF_FILE="pdf-docs/NextJS_Canary_Docs.pdf"
          node -e "
          const puppeteer = require('./tmp_mdx_project/node_modules/puppeteer');
          (async () => {
            const browser = await puppeteer.launch({args:['--no-sandbox','--disable-setuid-sandbox'],timeout:0});
            const page = await browser.newPage();
            await page.goto('file://' + process.cwd() + '/pdf-docs/NextJS_Canary_Docs.html', {waitUntil: 'networkidle0'});
            await page.pdf({path: '$PDF_FILE', format: 'A4', printBackground: true});
            await browser.close();
          })();
          "

      - name: Upload HTML & PDF as Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nextjs-docs
          path: |
            pdf-docs/NextJS_Canary_Docs.html
            pdf-docs/NextJS_Canary_Docs.pdf