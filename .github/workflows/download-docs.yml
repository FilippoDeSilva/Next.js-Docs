name: Build Docs PDF

on:
  push:
    paths:
      - 'nextjs-docs/**'
  workflow_dispatch:

jobs:
  build-pdf:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install deps
        run: |
          mkdir -p tmp_mdx_project
          cd tmp_mdx_project
          npm init -y
          npm install @mdx-js/mdx puppeteer fs-extra
          cd ..

      - name: Prepare directories
        run: |
          mkdir -p pdf-docs html_cache

      - name: Collect MDX files
        run: |
          DOCS_PATH="nextjs-docs/canary_docs/docs"
          if [ ! -d "$DOCS_PATH" ]; then
            echo "ERROR: Docs folder not found: $DOCS_PATH"
            exit 1
          fi
          mapfile -t files < <(find "$DOCS_PATH" -type f \( -name "*.md" -o -name "*.mdx" \) | sort)
          if [ "${#files[@]}" -eq 0 ]; then
            echo "No Markdown/MDX files found in $DOCS_PATH"
            exit 1
          fi
          printf '%s\n' "${files[@]}" > tmp_files.txt
          echo "Found ${#files[@]} files."

      - name: Compile MDX → HTML in parallel
        run: |
          node <<'EOF'
          const fs = require('fs-extra');
          const path = require('path');
          const { Worker } = require('worker_threads');
          const mdxPath = path.resolve('tmp_mdx_project/node_modules/@mdx-js/mdx');
          const files = fs.readFileSync('tmp_files.txt','utf8').split('\n').filter(Boolean);
          const htmlDir = path.resolve('html_cache'); fs.ensureDirSync(htmlDir);
          const concurrency = Math.min(require('os').cpus().length, 4);

          let index = 0;
          function runWorker(file) {
            return new Promise((resolve, reject) => {
              const worker = new Worker(\`
                const { parentPort, workerData } = require('worker_threads');
                const fs = require('fs-extra');
                const mdx = require(workerData.mdx);
                (async () => {
                  const content = await fs.readFile(workerData.file, 'utf8');
                  const html = '<div>' + (await mdx.compile(content)).value + '</div>';
                  const outFile = workerData.htmlDir + '/' + path.basename(workerData.file).replace(/[\\/:\\s]/g,'_') + '.html';
                  await fs.writeFile(outFile, html);
                  parentPort.postMessage(workerData.file);
                })().catch(err => { throw err; });
              \`, { eval:true, workerData: { file, htmlDir, mdx: mdxPath } });
              worker.on('message', resolve);
              worker.on('error', reject);
            });
          }

          async function main() {
            const pool = [];
            while(index < files.length || pool.length) {
              while(index < files.length && pool.length < concurrency) {
                pool.push(runWorker(files[index++]));
              }
              await Promise.race(pool).then(() => pool.splice(pool.findIndex(p => true),1)).catch(() => {});
            }

            const htmlFiles = fs.readdirSync(htmlDir).sort();
            const htmlOut = fs.createWriteStream('pdf-docs/NextJS_Canary_Docs.html');
            htmlOut.write('<html><head><meta charset="UTF-8"></head><body>\n');
            for(const f of htmlFiles){
              htmlOut.write(fs.readFileSync(path.join(htmlDir,f),'utf8') + '\n');
            }
            htmlOut.write('</body></html>\n');
            htmlOut.close();
          }

          main().catch(err => { console.error(err); process.exit(1); });
          EOF

      - name: Convert HTML → PDF
        run: |
          node <<'EOF'
          const puppeteer = require('tmp_mdx_project/node_modules/puppeteer');
          (async () => {
            const browser = await puppeteer.launch({ args:['--no-sandbox','--disable-setuid-sandbox'], timeout:0 });
            const page = await browser.newPage();
            await page.goto('file://' + process.cwd() + '/pdf-docs/NextJS_Canary_Docs.html', { waitUntil:'networkidle0', timeout:0 });
            await page.pdf({ path:'pdf-docs/NextJS_Canary_Docs.pdf', format:'A4', printBackground:true });
            await browser.close();
          })();
          EOF

      - name: Record hash
        run: echo "f8816b06" > docs_hash.txt